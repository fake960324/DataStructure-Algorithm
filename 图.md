# 什么是图
* 表示`多对多`关系
* 包含
  * 一组`顶点`：通常用V（Vertex）表示顶点集合
  * 一组`边`：通常用E（Edge）表示边的集合
    * 边是顶点对：`无向边`（v,w）∈E，其中v,w∈V
    * `有向边`<v,w>：表示从v指向w（单行线）
    不考虑`重边`和`自回路`
* 抽象数据类型定义
  * 类型名称：图（Graph）
  * 数据对象集：G（V,E）由一个`非空`的有限顶点集合V和一个有限边集合E组成。
  * 操作集：对于任意图G属于Graph，以及v∈V，e∈E
    * Graph Create():`建立`并返回空图
    * Graph InsertVertex(Graph G, Vertex v):将`顶点v插入`到图G
    * Graph InsertEdge(Graph G, Edge e):将`边e插入`到图中
    * void DFS(Graph G,Vertex v):从顶点v开始`深度优先遍历`
    * void BFS(Graph G,Vertex v):从顶点v开始`宽度优先遍历`
    * void ShortestPath(Graph G, Vertex v, int Dist[]):计算图G中顶点v到其他顶点的`最短距离`
    * void MST(Graph G):计算图G的`最小生成树`
# 图的表示
* 邻接矩阵
邻接矩阵G[N][N]——N个顶点从0到N-1编号<br>
![邻接矩阵表示法](https://latex.codecogs.com/svg.latex?%20G[i][j]=\begin{cases}1%20,%3Cv_i,v_j%3E%20\in%20G\\\\0,else\end{cases})<br>
  * 问题：对于`无向图`存储，怎样科技节省空间？<br>
![无向图数组存储](https://github.com/fake960324/DataStructure-Algorithm/blob/master/Pics/%E6%97%A0%E5%90%91%E5%9B%BE%E5%AD%98%E5%82%A8.jpg)<br>
  * 好处
    * 直观、简单、好理解
    * 方便检查任意一对顶点间`是否存在边`
    * 方便找任一顶点的所有`邻接点`
    * 方便计算任一顶点的`度`（从该点发出的边数为`出度`，指向该点的边数为`入度`）
  * 缺点
    * 浪费空间：存`稀疏图`（点很多而便很少）有大量无效元素
    * 浪费时间：统计稀疏图中共有多少条边
* 邻接表
G[N]为`指针数组`，对应矩阵每一行一个连边，只存非0元<br>
*一定要够稀疏才合算*
  * 特点
    * 方便找任一顶点的所有`邻接点`
    * 节约`稀疏图`的存储空间
      * 需要N个头指针+2E个节点（每个节点至少2个域）
    * 方便计算任一节点的`度`
      * 对`无向图`：是的
      * 对`有向图`：智能计算`出度`；需要构造`逆邻接表`（存储只想自己的边）来方便计算`入度`
    * *不方便* 检查任意一对顶点间是否存在边
# 图的遍历
* 深度优先遍历
``` C
void DFS(Vertex v)
{
 visted[v]=true;
 for(v的邻接节点w)
 {
  if(visted[w]!=true)
   DFS(w);
 }
}
```
N个顶点、E条边，时间复杂度：找到该顶点，从该顶点开始DFS
  * 邻接表存储：O(N+E)：每个节点都访问了一次，每条边都访问了一次
  * 邻接矩阵：O(N^2)：要找到邻接矩阵中某顶点的边，需要遍历该行，也就是N个位置。总体就是N*N个位置
* 广度优先遍历
``` C
void BFS(Vertex v)
{
  int temp;
  Queue q；
  q.enqueue(v);
  while(!q.IsEmpty())
  {
    temp=q.dequeue(v);
    visted[temp]=true;
    for(temp的所有邻接顶点w)
    {
      if(visted[w]!=true)
      {
       q.enqueue(w);
      }
    }
  }
}
```
 N个顶点、E条边，时间复杂度：找到该顶点，从该顶点开始BFS
  * 邻接表：O(N+E)
  * 邻接矩阵：O(N^2)
# 图的连通
无向图：
* `连通`：如果从v到w存在一条（无向）`路径`则称v和w是连通的
* `路径`：v到w的路径是一系列顶点{V，v1,v2,...,vn，w}的集合，其中任一对相邻的顶点间都有图的边。`路径的长度`是路径中的边数（带权边是所有边的权重和）。如果v到w之间的所有顶点都不同，则称`简单路径`
* `回路`：起点等于重点的路径
* `连通图`：图中`任意`两顶点的`均连通`
* `连通分量`：无向图的`极大`连通子图
  * 极大顶点数：再加1个顶点就不连通了
  * 极大边数：包含子图中的所有边

有向图：
* `强联通`：有向图中顶点v和w之间存在`双向路径`
* `强连通图`：有向图中任意两定点均是强联通
* `连通子图`：有向图的极大强联通子图
* `弱连通`：有向图中忽略边的方向的`连通`
**每调用一次DFS，就把V的所在的连通分量遍历了一边。BFS也是一样**
```c
//遍历图中所有顶点
void ListComponents(Graph G)
{
  for(each V in G)
  {
    if(!visited[V])
      DFS(V);
  }
}
```
# 最短路径问题
* 在网络中，求两个不同顶点之间的所有路径中，变得`权值之和最小`的那条路径
  * 这了路径就是两点之间的`最短路径`（ShortestPath）
  * 第一个顶点为`源点`（source）
  * 最后一个顶点为`终点`（destination）
* `单源最短路径`问题：从某源点触发，求其到`所有其他顶点`的最短路径
  * （有向）无权图
   * 按照`递增`（非递减）的顺序找出各个顶点的最短路<br>
   ![无权图最短路径](https://github.com/fake960324/DataStructure-Algorithm/blob/master/Pics/%E6%97%A0%E6%9D%83%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.jpg)<br>
   ```c
   //dist[w]:S到w的最短距离
   //dist[S]=0;
   //path[w]：S到w路径上的某顶点。w的前一个顶点
   void Unweighted(Vertex S)
   {
     Enqueue(S,Q);
     while(!IsEmpty(Q))
     {
       V=Dqueue(Q);
       for(V的每个邻接节点w)
       {
         if(dist[w]==-1)
         {
           dist[w]=dist[v]+1;
           path[w]=v;
           Enqueue(w,Q);
         }
       }
     }
   }
   ```
   时间复杂度O(V+E)：每个节点都只enqueue了一次。每条边都遍历了一次。
  * （有向）有权图
  
* `多源最短路径`问题：求任意两顶点间的最短路径
 
